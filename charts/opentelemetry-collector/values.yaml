global:
  name: aspecto
  namespace: dev
  env: {}
  aspecto:
    existingSecret: false
    apiToken: ''
    interval: 60
  rolloutStrategy:
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 3
    type: RollingUpdate
  metadata:
    shared:
      annotations:
        helm/deploymentTimestamp: "{{ now | unixEpoch }}"
      labels:
        app: opentelemetry
        loadBalancerVersion: "{{ .Values.load_balancer.image.version | default .Values.global.image.version }}"
        samplingCollectorVersion: "{{ .Values.sampling_collector.image.version | default .Values.global.image.version }}"
        chart/name: "{{ .Chart.Name }}"
        chart/release: "{{ .Chart.Version }}"
    pod:
      annotations: {}
      labels: {}
    deployment:
      annotations: {}
      labels: {}
    service:
      annotations: {}
      labels: {}
    configMap:
      annotations: {}
      labels: {}
    hpa:
      annotations: {}
      labels: {}
    virtualService:
      annotations: {}
      labels: {}
    destinationRule:
      annotations: {}
      labels: {}
    gateway:
      annotations: {}
      labels: {}
    secret:
      annotations: {}
      labels: {}
  image:
    repository: 'public.ecr.aws/x3s3n8k7'
    pullPolicy: Always
    version: 'v0.0.1-rc2'

load_balancer:
  image:
    repository: ''
    policy: IfNotPresent
    name: 'otelcol-loadbalancing'
    version: ''

  metadata:
    name: load-balancer
    namespace: ''
    shared:
      annotations: {}
      labels: {}
    pod:
      annotations: {}
      labels:
        component: otel-collector-load-balancer-pod
    deployment:
      annotations: {}
      labels: {}
    service:
      annotations: {}
      labels:
        component: otel-collector-load-balancer-service
    configMap:
      annotations: {}
      labels: {}
    hpa:
      annotations: {}
      labels: {}
    virtualService:
      annotations: {}
      labels: {}
    destinationRule:
      annotations: {}
      labels: {}
    gateway:
      annotations: {}
      labels: {}

  env: {}

  specs:
    configuration:
      exporters:
        load_balancing:
          protocol:
            otlp:
              timeout: 1s
              tls:
                insecure: true
            resolver:
              dns:
                hostname:
                port: 4137
      log:
        enable: true
        level: debug
      endpoint: ''

    autoscaling:
      enable: true
      defaultReplicaCount: 3
      minReplicas: 3
      maxReplicas: 20
      targetCPUUtilizationPercentage: 75
      targetMemoryUtilizationPercentage: 75

    resources:
      limits:
        cpu: 2
        memory: 2Gi
      requests:
        cpu: 1
        memory: 1Gi

    probe:
      readinessProbe:
        httpGet:
          path: /
          port: 8090
        initialDelaySeconds: 10
        periodSeconds: 3
      livenessProbe:
        httpGet:
          path: /
          port: 8090
        initialDelaySeconds: 10
        periodSeconds: 30

    volumes:
      serviceConfig:
        name: service-configuration
        mountPath: /config
        fileName: loadbalancing-config.yml
      extraVolumes: []
      # - name: configMapName
      #   mountPath: /folder/path
      #   subPath: filename.ext
      extraSecretMounts: []
      # - name: secret-files
      #   mountPath: /path/to/file
      #   secretName: secret-key-name
      #   readOnly: true|false

    network:
      localListenerIp: 0.0.0.0
      type: None
      ports:
        - name: grpc          # Default endpoint for OpenTelemetry gRPC receiver.
          internalPort: 4317
          externalPort: 4317
          protocol: TCP
        - name: http          # Default endpoint for OpenTelemetry HTTP receiver.
          internalPort: 4318
          externalPort: 4318
          protocol: TCP
        - metrics:
          name: metrics       # Default endpoint for querying metrics.
          internalPort: 8888
          externalPort: 8888
          protocol: TCP
        - name: health-check  # Default endpoint for querying open-telemetry health.
          internalPort: 8090
          externalPort: 8090
          protocol: TCP
      istio:
        enabled: false
        rules:
        - name: 'port-9000-uri-root'
          ingress:
            - uriPrefix: "/"
              host: "{{ .Values.global.loadBalancerEndpoint }}"
              destinationPort: 8090
          hostHeader:
            - '*'

    services:
      - name: loadbalancer
        # Currently, we support 3 service types (ClusterIP, LoadBalancer)
        # Internal - An internal service is a service that would only be accessed from inside the Kubernetes cluster.
        # It will receive an internal IP address that other Kubernetes services could access to consume the service from.
        #
        # ClusterIP - This will create a simple service that would supply DNS round-robin load balancing for the service.
        # This  will give external cluster access by a dedicated DNS address: <serviceName>.<namespace>.svc.kube.<cluster>.com
        # This option is for when you need the most basic and simple load balancing.
        #
        # LoadBalancer - This is for when you need complex load balancing options. Based on user headers or specific uri prefixes.
        # This is also the only option that would utilize Istio (https://istio.io/).
        serviceType: LoadBalancer

        selector:
          component: otel-collector-load-balancer-pod

        ports:
          - name: grpc          # Name of the port (Should match one of the ports in the containers)
            type: grpc          # The Type of the port the service is exposing. The valid options are <http/http2/grpc/mongo/redis/tcp/tls/udp>
            protocol: TCP
            externalPort: 4317  # Port the service exposes
            internalPort: 4317  # Port the service accesses when redirecting to the pod
            loadBalancer:
              simple: LEAST_CONN
          - name: http
            type: http
            externalPort: 4318
            internalPort: 4318
            protocol: TCP
            loadBalancer:
              simple: LEAST_CONN
          - name: health-check
            type: http
            externalPort: 8090
            internalPort: 8090
            protocol: TCP
            loadBalancer:
              simple: LEAST_CONN
          - name: metrics
            type: http
            externalPort: 8888
            internalPort: 8888
            protocol: TCP
            loadBalancer:
              simple: LEAST_CONN

sampling_collector:
  image:
    repository: ''
    policy: Always
    name: 'otelcol-sampling'
    version: ''

  metadata:
    name: sampling-collector
    namespace: ''
    shared:
      annotations: {}
      labels: {}
    pod:
      annotations: {}
      labels:
        component: otel-collector-sampling-collector
    deployment:
      annotations: {}
      labels: {}
    service:
      annotations: {}
      labels: {}
    configMap:
      annotations: {}
      labels: {}
    hpa:
      annotations: {}
      labels: {}
    virtualService:
      annotations: {}
      labels: {}
    destinationRule:
      annotations: {}
      labels: {}
    gateway:
      annotations: {}
      labels: {}

  env: {}

  specs:
    configuration:
      endpoint: https://collector.aspecto.io
      decision_wait: 10s
      num_traces: 100
      expected_new_traces_per_sec: 10
      policies: $$aspecto:tail_sampling_policy
      log:
        enable: true
        level: debug

    autoscaling:
      enable: true
      defaultReplicaCount: 3
      minReplicas: 3
      maxReplicas: 20
      targetCPUUtilizationPercentage: 75
      targetMemoryUtilizationPercentage: 75

    resources:
      limits:
        cpu: 2
        memory: 2Gi
      requests:
        cpu: 1
        memory: 1Gi

    probe:
      readinessProbe:
        httpGet:
          path: /
          port: 8090
        initialDelaySeconds: 10
        periodSeconds: 3
      livenessProbe:
        httpGet:
          path: /
          port: 8090
        initialDelaySeconds: 10
        periodSeconds: 30

    volumes:
      serviceConfig:
        name: service-configuration
        mountPath: /config
        fileName: sampling-config.yml
      extraVolumes: []
      # - name: configMapName
      #   mountPath: /folder/path
      #   subPath: filename.ext
      extraSecretMounts: []
      # - name: secret-files
      #   mountPath: /path/to/file
      #   secretName: secret-key-name
      #   readOnly: true|false

    network:
      localListenerIp: 0.0.0.0
      type: LoadBalancer
      serviceName: opentelemetry-sampling
      ports:
        - name: grpc          # Default endpoint for OpenTelemetry gRPC receiver.
          internalPort: 4317
          externalPort: 4317
          protocol: TCP
        - name: http          # Default endpoint for OpenTelemetry HTTP receiver.
          internalPort: 4318
          externalPort: 4318
          protocol: TCP
        - metrics:
          name: metrics       # Default endpoint for querying metrics.
          internalPort: 8888
          externalPort: 8888
          protocol: TCP
        - name: health-check  # Default endpoint for querying open-telemetry health.
          internalPort: 8090
          externalPort: 8090
          protocol: TCP
      istio:
        enabled: false
        rules:
          - name: 'port-9000-uri-root'
            ingress:
              - uriPrefix: "/"
                host: "{{ .Values.global.loadBalancerEndpoint }}"
                destinationPort: 4317
            hostHeader:
              - '*'

    services:
      - name: tail-sampling
        # Currently, we support 2 service types (ClusterIP, LoadBalancer)
        # Internal - An internal service is a service that would only be accessed from inside the Kubernetes cluster.
        # It will receive an internal IP address that other Kubernetes services could access to consume the service from.
        #
        # ClusterIP - This will create a simple service that would supply DNS round-robin load balancing for the service.
        # This  will give external cluster access by a dedicated DNS address: <serviceName>.<namespace>.svc.kube.<cluster>.com
        # This option is for when you need the most basic and simple load balancing.
        #
        # LoadBalancer - This is for when you need complex load balancing options. Based on user headers or specific uri prefixes.
        # This is also the only option that would utilize Istio (https://istio.io/).
        serviceType: ClusterIP

        selector:
          component: otel-collector-sampling-collector

        ports:
          - name: grpc            # Name of the port (Should match one of the ports in the containers)
            type: grpc            # The Type of the port the service is exposing. The valid options are <http/http2/grpc/mongo/redis/tcp/tls/udp>
            externalPort: 8081    # Port the service exposes
            internalPort: 4317    # Port the service accesses when redirecting to the pod
            protocol: TCP
            selector:
              component: sampling-collector
            loadBalancer:
              simple: LEAST_CONN
          - name: http
            type: http
            externalPort: 8082
            internalPort: 4318
            protocol: TCP
            selector:
              component: sampling-collector
            loadBalancer:
              simple: LEAST_CONN  # We support only simple load balancing algorithms. the valid options are <ROUND_ROBIN/LEAST_CONN/RANDOM>
          - name: health-check
            type: http
            externalPort: 8083
            internalPort: 8090
            protocol: TCP
            loadBalancer:
              simple: LEAST_CONN
          - name: metrics
            type: http
            externalPort: 8084
            internalPort: 8888
            protocol: TCP
            loadBalancer:
              simple: LEAST_CONN
